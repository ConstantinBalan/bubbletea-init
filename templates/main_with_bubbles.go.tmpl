package main

import (
	"fmt"
	"os"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/charmbracelet/lipgloss"
)

var style = lipgloss.NewStyle().
	Bold(true).
	Foreground(lipgloss.Color("#FAFAFA")).
	Background(lipgloss.Color("#7D56F4")).
	PaddingTop(1).
	PaddingBottom(1).
	PaddingLeft(4).
	PaddingRight(4)

type model struct {
	spinner  spinner
	input    textInput
	loading  bool
	value    string
	quitting bool
}

func initialModel() model {
	return model{
		spinner: newSpinner(),
		input:   newTextInput(),
	}
}

func (m model) Init() tea.Cmd {
	return tea.Batch(
		m.spinner.init(),
		m.input.init(),
	)
}

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.String() {
		case "ctrl+c", "q":
			m.quitting = true
			return m, tea.Quit
		case "enter":
			if m.input.value != "" {
				m.loading = true
				m.value = m.input.value
				m.input.reset()
				return m, tea.Tick(2*time.Second, func(t time.Time) tea.Msg {
					return loadingFinishedMsg{}
				})
			}
		}
	case loadingFinishedMsg:
		m.loading = false
	}

	var cmd tea.Cmd
	m.spinner, cmd = m.spinner.update(msg)
	if !m.loading {
		var inputCmd tea.Cmd
		m.input, inputCmd = m.input.update(msg)
		return m, tea.Batch(cmd, inputCmd)
	}
	return m, cmd
}

func (m model) View() string {
	if m.quitting {
		return "Goodbye! ðŸ‘‹\n"
	}

	var s strings.Builder

	s.WriteString(style.Render("{{.ProjectName}}") + "\n\n")

	if m.loading {
		s.WriteString(fmt.Sprintf("%s Loading: %s...\n", m.spinner.view(), m.value))
	} else if m.value != "" {
		s.WriteString(fmt.Sprintf("Last value: %s\n\n", m.value))
		s.WriteString(m.input.view())
	} else {
		s.WriteString(m.input.view())
	}

	s.WriteString("\n\nPress q to quit\n")

	return s.String()
}

func main() {
	p := tea.NewProgram(initialModel())
	if _, err := p.Run(); err != nil {
		fmt.Println("Error:", err)
		os.Exit(1)
	}
}

// Spinner component
type spinner struct {
	frames  []string
	current int
}

func newSpinner() spinner {
	return spinner{
		frames: []string{"â ‹", "â ™", "â ¹", "â ¸", "â ¼", "â ´", "â ¦", "â §", "â ‡", "â "},
	}
}

func (s spinner) init() tea.Cmd {
	return tea.Tick(100*time.Millisecond, func(t time.Time) tea.Msg {
		return spinnerTickMsg{}
	})
}

func (s spinner) update(msg tea.Msg) (spinner, tea.Cmd) {
	switch msg.(type) {
	case spinnerTickMsg:
		s.current = (s.current + 1) % len(s.frames)
		return s, s.init()
	default:
		return s, nil
	}
}

func (s spinner) view() string {
	return s.frames[s.current]
}

// Text input component
type textInput struct {
	value string
}

func newTextInput() textInput {
	return textInput{}
}

func (t textInput) init() tea.Cmd {
	return nil
}

func (t textInput) update(msg tea.Msg) (textInput, tea.Cmd) {
	switch msg := msg.(type) {
	case tea.KeyMsg:
		switch msg.Type {
		case tea.KeyBackspace:
			if len(t.value) > 0 {
				t.value = t.value[:len(t.value)-1]
			}
		case tea.KeyRunes:
			t.value += string(msg.Runes)
		}
	}
	return t, nil
}

func (t textInput) view() string {
	return fmt.Sprintf("Enter some text: %sâ–ˆ", t.value)
}

func (t *textInput) reset() {
	t.value = ""
}

// Custom messages
type spinnerTickMsg struct{}
type loadingFinishedMsg struct{}